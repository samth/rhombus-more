#lang rhombus

import:
  rhombus/macro: no_prefix
  racket/control
  "param.rkt"
  racket/list:
    prefix l
  racket/base:
    prefix string
    rename:
      #{string->number} ~to to_number
  racket/format:
    rename:
      #{~a} ~to a
  racket/dict:
    rename:
      #{dict-ref} ~to ref
  racket/base:
    prefix custodian
    rename:
      #{current-custodian} ~to current
      #{custodian-shutdown-all} ~to shutdown
      #{make-custodian} ~to make
      #{custodian-limit-memory} ~to limit_memory

fun map(f): fun(l): r.map(f,l)

expr.rule '(letcc $k: $body ...; ...):
  '(r.callcc(fun($k): $body ...; ...))
                
// how do i write symbols?
expr.rule '(s $id):
  '(symbol($id))
  
expr.rule '(loop: $body ...; ...):
  '(begin:
      fun lp():
        $body ...; ...
        lp()
      lp())

expr.rule '(thunk: $body ... ; ...):
  '(fun (): $body ... ; ...)


expr.rule '(thread: $body ... ; ...):
  '(r.thread(thunk: $body ... ; ...))

expr.rule '(parameterize ($a ..., $b ...): $body ... ; ...):
  '(param.parameterize_rhom($a ...,$b ..., begin: $body ...; ...))
     
operator(a ++ b):
  r.#{string-append}(a, b)
  
import:
  racket/tcp:
    rename:
      #{tcp-listen} ~to listen
      #{tcp-accept} ~to accept
      #{tcp-close} ~to close
  racket/base:
    prefix r
    rename:
      #{call/cc} ~to callcc
      #{regexp-match} ~to regexp_match
      #{close-input-port} ~to close_input_port
      #{close-output-port} ~to close_output_port
      #{current-custodian} ~to current_custodian
      #{custodian-shutdown-all} ~to custodian_shutdown_all
      #{hash-ref} ~to hash_ref
      #{hash-set!} ~to hash_set
      #{string->number} ~to string_to_number
      #{number->string} ~to number_to_string
      #{make-hash} ~to make_hash
      #{current-inexact-milliseconds} ~to current_inexact_milliseconds
  xml:
    rename:
      #{xexpr->string} ~to to_string
  net/url:
    prefix url
    rename:
      #{string->url} ~to from_string
      #{url-path} ~to path
      #{url-query} ~to query
      #{path/param-path} ~to param_path
      
    
    

fun close_port(p):
 if r.#{input-port?}(p)
 | r.close_input_port(p)
 | r.close_output_port(p)


fun is_port(p): r.#{input-port?}(p) || r.#{output-port?}(p)

expr.rule '(when $e: $body ... ; ...):
  '(if $e
    | begin: $body ... ; ...
    | r.void())

 
annotation.macro 'Port:
  annotation_ct.pack_predicate('is_port,
                               '(($(dot_ct.provider_key), port_dot_provider)))
dot.macro '(port_dot_provider $left $dot $right):
  match right
  // One argument functions
  | 'display:       '(fun(arg):(r.display(arg,$left)))
  | 'match:         '(fun(arg):(r.regexp_match(arg,$left)))
  | 'close:         '(fun (): close_port($left))
  // this one doesn't work for some reason
  | 'readline:      '(fun (): r.#{read-line}($left))


operator (a |> b): b(a)

annotation.macro 'Thread:
  annotation_ct.pack_predicate('(r.#{thread?}),
                               '(($(dot_ct.provider_key), thread_dot_provider)))
dot.macro '(thread_dot_provider $left $dot $right):
  match right
  // One argument functions
  | 'kill: '(r.#{kill-thread}($left))

annotation.macro 'Tcp:
  annotation_ct.pack_predicate('(tcp.#{tcp-listener?}),
                               '(($(dot_ct.provider_key), tcp_dot_provider)))
dot.macro '(tcp_dot_provider $left $dot $right):
  match right
  // One argument functions
  | 'close:  '(fun(): (tcp.close($left)))
  | 'accept: '(fun(): (tcp.accept($left)))


annotation.macro 'Custodian:
  annotation_ct.pack_predicate('(r.#{custodian?}),
                               '(($(dot_ct.provider_key), custodian_dot_provider)))
dot.macro '(custodian_dot_provider $left $dot $right):
  match right
  // One argument functions
  | 'limit_memory:  '(fun(arg): (custodian.limit_memory($left, arg)))
  | 'shutdown: '(fun(): (custodian.shutdown($left)))


annotation.macro 'Alist:
  annotation_ct.pack_predicate('(r.#{list?}),
                               '(($(dot_ct.provider_key), alist_dot_provider)))
dot.macro '(alist_dot_provider $left $dot $right):
  match right
  // One argument functions
  | 'ref:  '(fun(arg): (dict.ref($left, arg)))



export:
  |>
  Custodian
  custodian_dot_provider
  Tcp
  tcp_dot_provider
  Thread
  thread_dot_provider
  Port
  port_dot_provider
  when
  parameterize
  thunk
  thread
  Alist
  when
  alist_dot_provider
  map
  loop
  s
  ++
  letcc
  